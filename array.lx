
inline C <<end
datum array_mtab;

#define CLIP_LEN(l) ((l) & 0x0fffffff)

void
array_init()
{
    array_mtab = (datum) lxc_module_array.instrs +
                         lxc_module_array.label_offsets[4];
}

datum
make_array(uint len)
{
    datum p;

    if (len < 1) return nil;
    if (len != CLIP_LEN(len)) die("make_array -- too big");
    p = make_record(len, array_mtab, nil, nil);
    for (;--len;) p[len] = (size_t) nil;
    return p;
}

end

def array ():
  inline C (get i) <<end
    int i;

    if (!intp(n_i)) die1("array.get -- not an int", n_i);

    i = datum2int(n_i);
    return array_get(rcv, i);
  end

  inline C (put! i v) <<end
    int i;

    if (!intp(n_i)) die1("array.put! -- not an int", n_i);

    i = datum2int(n_i);
    array_put(rcv, i, n_v);
    return ok_sym;
  end

  (filter f):
    def rest ((array.cdr).filter f)
    ? (f (array.car)):
      cons (array.car) rest
      . rest

  (run f):
    f (array.car)
    (array.cdr) f
    . 'ok

  (= p):
    ? ((array.car) = (p.car)):
      ? ((array.cdr) = (p.cdr)) true false
      . false

  (assq name):
    ? (is? (array.car.car) name) (array.car) (array.cdr.assq name)

def install-array ():
  inline C (run sur) <<end
    array_surrogate = n_sur;
    return ok_sym;
  end

install-array array

def make-array: sobj:
  inline C (run size) <<end
    if (!intp(n_size)) die1("make-array -- not an int", n_size);
    return make_array(datum2int(n_size));
  end

return make-array
