inline C <<end
#include <string.h>
#include <stdio.h>
#include <sys/stat.h>

static datum read_sym, write_sym;

static size_t
fsize(FILE *f)
{
    int r;
    struct stat sbuf;

    r = fstat(fileno(f), &sbuf);
    if (r) die("fsize -- cannot stat");
    return sbuf.st_size;
}

end

def intern-syms ():
  inline C (run) <<end
    read_sym = intern("read");
    write_sym = intern("write");
    return ok_sym;
  end

def file ():
  (run name mode):
    def f ():
      inline C (read) <<end
        uint r, len;
        datum str;
        FILE *f = (FILE *) ((chunk) rcv)->datums[2];
        char *s;

        if (!f) die("f:read -- this file is closed");
        len = fsize(f);
        str = make_bytes(len + 1);
        for (s = bytes_contents(str); len; len -= r) {
            r = fread(s, sizeof(char), len, f);
            // TODO error checking with feof() and ferror()
            s += r;
        }
        *s = '\0';
        return str;
      end

      inline C (write s) <<end
        uint r, len;
        FILE *f = ((chunk) rcv)->datums[2];
        char *s;

        if (!f) die("f:write -- this file is closed");
        s = bytes_contents(n_s);
        for (len = strlen(s); len; len -= r) {
            r = fwrite(s, sizeof(char), len, f);
            // TODO error checking with feof() and ferror()
            s += r;
        }
        return ok_sym;
      end

      inline C (close) <<end
        FILE *f = ((chunk) rcv)->datums[2];

        if (f) {
            fclose(f);
            ((chunk) rcv)->datums[2] = 0;
        }
        return ok_sym;
      end

      inline C (prepare) <<end
        FILE *f;
        char *mode = "rb";

        // Get mode
        if (n_mode == write_sym) {
            mode = "wb";
        } else if (n_mode != read_sym) {
            return die1("f:prepare -- unknown mode", n_mode);
        }

        f = fopen(bytes_contents(n_name), mode);

        return grow_closure(&rcv, 1, (na_fn_free) fclose, f);
      end

    f.prepare

intern-syms
. file
