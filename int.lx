
inline C <<end
#define MAX_LX_INT (0x3fffffff)
#define MIN_LX_INT (-0x40000000)

#define bigint(x) (printf("%ld\n", (x)), die1("no bigints yet", nil))
end

def int ():
  inline C (cmp b) <<end
    register long a, b;

    a = datum2int(rcv);
    b = datum2int(n_b);
    return (a < b) ? int2datum(-1) : (a > b) ? int2datum(1) : int2datum(0);
  end

  (= x) (is? (int.cmp x) 0)
  (> x) (is? (int.cmp x) 1)
  (< x) (is? (int.cmp x) -1)

  inline C ("+" b) <<end
    register long a, b, r;

    a = datum2int(rcv);
    b = datum2int(n_b);
    r = a + b;
    if (r >= MAX_LX_INT || r <= MIN_LX_INT) return bigint(r);
    return int2datum(r);
  end

  inline C (- b) <<end
    register long a, b, r;

    a = datum2int(rcv);
    b = datum2int(n_b);
    r = a - b;
    if (r >= MAX_LX_INT || r <= MIN_LX_INT) return bigint(r);
    return int2datum(r);
  end

  inline C ("*" b) <<end
    register long a, b, r;

    a = datum2int(rcv);
    b = datum2int(n_b);
    if (b == 0) die("int.* -- modulo by zero");
    r = a * b;
    if (b == 0 || (r / b) == a) {
      if (r >= MAX_LX_INT || r <= MIN_LX_INT) return bigint(r);
      return int2datum(r);
    }
    die("should convert to bigints and try again");
    return nil;
  end

  inline C (/ b) <<end
    register long a, b, r;

    a = datum2int(rcv);
    b = datum2int(n_b);
    if (b == 0) die("int./ -- division by zero");
    r = a / b;
    if (r == MAX_LX_INT + 1) return bigint(r);
    return int2datum(r);
  end

  inline C (% b) <<end
    register long a, b, r;

    a = datum2int(rcv);
    b = datum2int(n_b);
    if (b == 0) die("int.% -- modulo by zero");
    r = a % b;
    return int2datum(r);
  end

  (** x) (error "not implemented")

  (str):
    def upper (int / 10)
    def lower (int % 10)
    def table "0123456789"
    if (int < 10):
      table int
      (upper.str) / (table lower)

def install-int ():
  inline C (run surrogate) <<end
    int_surrogate = n_surrogate;
    return ok_sym;
  end

install-int int

. '()
