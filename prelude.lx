# This is the standard prelude for LX.

inline C <<<<
#include "prim.h"
>>>>

def Ï€ 3.14159

def open (import file)

def call ():
  inline C run <<<<
    datum obj, msg, argl;
    obj = checked_car(args);
    msg = checked_cadr(args);
    argl = checked_caddr(args);
    return call(obj, msg, argl);
  >>>>

def error ():
  inline C run <<<<
    die("TODO implement me -- prim_error\n");
    return nil;
  >>>>

def inspect ():
  inline C has-method? <<<<
    return (datum) compiled_obj_has_method(car(args), cadr(args));
  >>>>
  inline C same-type? <<<<
    return (datum) compiled_objs_same_type(car(args), cadr(args));
  >>>>

def is? ():
  inline C run <<<<
    if (args == nil) die("is? -- not enough args");
    if (cdr(args) == nil) die("is? -- not enough args");
    return (datum) (car(args) == cadr(args));
  >>>>

def cons ():
  inline C run <<<<
    if (args == nil) die("cons -- not enough args");
    if (cdr(args) == nil) die("cons -- not enough args");
    return cons(car(args), cadr(args));
  >>>>

def list ():
  inline C run <<<<
    return args;
  >>>>

def make-array ():
  inline C run <<<<
    if (args == nil) die("make-array -- not enough args");
    if (!intp(car(args))) die1("make-array -- not an int", car(args));
    return make_array(datum2int(car(args)));
  >>>>

def pr ():
  inline C run <<<<
    if (args == nil) die("pr -- not enough args");
    pr(car(args));
    return ok_sym;
  >>>>

def (make-queue):
    def front '()
    def rear '()
    def queue ():
        (empty?):
            is? front '()
        (front):
            if (queue :empty?) (error "front called on an empty queue")
            front :car
        (run item):
            def new (cons item '())
            if (queue :empty?):
                begin :
                    front :: new
                    rear :: new
                begin :
                    rear :set-cdr! new
                    rear :: new
            queue .
        (remove!):
            def item (queue :front)
            queue :delete!
            item .
        (delete!):
            if (queue :empty?) (error "delete! called on an empty queue")
            front :: (front :cdr)
            queue .
        (consume! f):
            if (queue :empty?):
                'ok .
                begin :
                    f (queue :remove!)
                    queue :consume! f
    queue .

def (make-promise):
    def resolved '()
    def value '()
    def queue (make-queue)

    def promise ():
        (wait f):
            if resolved :
                f .run value
                queue f

        (send msg args):
            def pp '()
            def p '()
            def s '()
            if resolved :
                send value msg args
                begin :
                    pp :: (make-promise)
                    p :: (pp :car)
                    s :: (pp :cdr)
                    queue : #[((send x msg args) :wait [(s x)])]
                        fn (x) :
                            (send x msg args) :wait (fn (y) (s y))
                    p .

    def (sink val):
        if resolved (error "sink given a value but promise is already resolved")
        resolved :: 1
        value :: val
        queue :consume! (fn (x) (x .run val))
        #queue :consume! [(x .run val)]
        queue :: '()

    cons promise sink

def (make-task rcv message args):
    def p (make-promise)
    def promise (p :car)
    def sink (p :cdr)

    def (resolve):
        sink (call rcv message args)

    cons promise resolve

def (send rcv msg args):
    def task '()
    if (inspect :has-method? rcv 'send):
        rcv :send msg args
        begin :
            task :: (make-task rcv msg args)
            *tasks* (task :cdr)
            task :car

def *tasks* (make-queue)
