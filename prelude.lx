# This is the standard prelude for LX.

inline C <<<<
#include "prim.h"
>>>>

def Ï€ 3.14159

def false '()
def true 1

def (not x) (if x false true)

def open (import file)

def call ():
  inline C run <<<<
    datum obj, msg, argl;
    obj = checked_car(args);
    msg = checked_cadr(args);
    argl = checked_caddr(args);
    return call(obj, msg, argl);
  >>>>

def error ():
  inline C run <<<<
    return report_error(args);
  >>>>

def inspect ():
  inline C has-method? <<<<
    return (datum) compiled_obj_has_method(car(args), cadr(args));
  >>>>
  inline C same-type? <<<<
    return (datum) compiled_objs_same_type(car(args), cadr(args));
  >>>>
  inline C methods <<<<
    return (datum) compiled_obj_methods(car(args));
  >>>>

def is? ():
  inline C run <<<<
    if (args == nil) die("is? -- not enough args");
    if (cdr(args) == nil) die("is? -- not enough args");
    return (datum) (car(args) == cadr(args));
  >>>>

def cons ():
  inline C run <<<<
    if (args == nil) die("cons -- not enough args");
    if (cdr(args) == nil) die("cons -- not enough args");
    return cons(car(args), cadr(args));
  >>>>

def list ():
  inline C run <<<<
    return args;
  >>>>

def make-array ():
  inline C run <<<<
    if (args == nil) die("make-array -- not enough args");
    if (!intp(car(args))) die1("make-array -- not an int", car(args));
    return make_array(datum2int(car(args)));
  >>>>

def pr ():
  inline C run <<<<
    if (args == nil) die("pr -- not enough args");
    pr(car(args));
    return ok_sym;
  >>>>

def (make-queue):
    def front '()
    def rear '()
    def queue ():
        (empty?):
            is? front '()
        (front):
            if (queue :empty?) (error "front called on an empty queue")
            front :car
        (run item):
            def new (cons item '())
            if (queue :empty?):
                begin :
                    front :: new
                    rear :: new
                begin :
                    rear :set-cdr! new
                    rear :: new
            queue .
        (remove!):
            def item (queue :front)
            queue :delete!
            item .
        (delete!):
            if (queue :empty?) (error "delete! called on an empty queue")
            front :: (front :cdr)
            queue .
        (consume! f):
            if (queue :empty?):
                'ok .
                begin :
                    f (queue :remove!)
                    queue :consume! f
    queue .

def (make-promise):
    def status 'pending # or resolved or broken

    def value '()
    def success-queue (make-queue)

    def err-name '()
    def err-val '()
    def err-queue (make-queue)

    def (resolved?) (is? status 'resolved)
    def (pending?) (is? status 'pending)
    def (broken?) (is? status 'broken)

    def promise ():
        (wait f):
            if (pending?) (success-queue f)
            if (resolved?) (f .run value)

        (wait-for-error f):
            if (pending?) (err-queue f)
            if (broken?) (f .run err-name err-val)

        (send msg args):
            if (pending?):
                begin :
                    def pp '()
                    def p '()
                    def s '()
                    #(p s) :: (make-promise)
                    pp :: (make-promise)
                    p :: (pp :car)
                    s :: (pp :cdr)
                    def f (fn (x) ((send x msg args):wait (fn (x) (s x))))
                    success-queue f
                    # promise:wait [(send x msg args):wait [s x]]
                    err-queue :
                        fn (x y) (s :break! x y)
                    # promise:wait-for-error [s:break! x y]
                    p .
                if (resolved?):
                    send value msg args
                    make-broken-promise err-name err-val # status is 'broken

    def sink ():
        (run val):
            if (resolved?) (error "sink given a value but promise is already resolved")
            status :: 'resolved
            value :: val
            #success-queue:consume! [x .run val]
            success-queue :consume! (fn (x) (x .run val))
            success-queue :: '()
            err-queue :: '()
        (break! name val):
            status :: 'broken
            err-name :: name
            err-val :: val
            #err-queue :consume! [x .run name val]
            err-queue :consume! (fn (x) (x .run name val))
            success-queue :: '()
            err-queue :: '()

    cons promise sink

def (make-broken-promise name val):
  def pp (make-promise)
  (pp :cdr) :break! name val
  pp .

def (make-task rcv message args):
    def p (make-promise)
    def promise (p :car)
    def sink (p :cdr)

    def resolver ():
        (run) (sink (call rcv message args))
        (break! x) (sink :break! 'error x)

    cons promise resolver

def (send rcv msg args):
    def task '()
    if (inspect :has-method? rcv 'send):
        rcv :send msg args
        begin :
            task :: (make-task rcv msg args)
            *tasks* (task :cdr)
            task :car

def *tasks* (make-queue)
