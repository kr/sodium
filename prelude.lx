# This is the standard prelude for LX.

inline C <<<<
#include "prim.h"
>>>>

def Ï€ 3.14159

def false '()
def true 1

def (not x) (if x false true)

def open (load-module file)

def call ():
  inline C run <<<<
    datum obj, msg, argl;
    obj = checked_car(args);
    msg = checked_cadr(args);
    argl = checked_caddr(args);
    return call(obj, msg, argl);
  >>>>

def error ():
  inline C run <<<<
    return report_error(args);
  >>>>

def inspect ():
  inline C has-method? <<<<
    return (datum) compiled_obj_has_method(car(args), cadr(args));
  >>>>
  inline C same-type? <<<<
    return (datum) compiled_objs_same_type(car(args), cadr(args));
  >>>>
  inline C methods <<<<
    return (datum) compiled_obj_methods(car(args));
  >>>>

# TODO replace this with 
def (promise? x): inspect.has-method? x 'wait

def (ensure try finally):
  def success [do (finally) x]
  def failure [do (finally) (error x y)]
  try:run.wait+ success failure

def is? ():
  inline C run <<<<
    if (args == nil) die("is? -- not enough args");
    if (cdr(args) == nil) die("is? -- not enough args");
    return (datum) (car(args) == cadr(args));
  >>>>

def cons ():
  inline C run <<<<
    if (args == nil) die("cons -- not enough args");
    if (cdr(args) == nil) die("cons -- not enough args");
    return cons(car(args), cadr(args));
  >>>>

def list ():
  inline C run <<<<
    return args;
  >>>>

def make-array ():
  inline C run <<<<
    if (args == nil) die("make-array -- not enough args");
    if (!intp(car(args))) die1("make-array -- not an int", car(args));
    return make_array(datum2int(car(args)));
  >>>>

def pr ():
  inline C run <<<<
    if (args == nil) die("pr -- not enough args");
    pr(car(args));
    return ok_sym;
  >>>>

def prx ():
  inline C run <<<<
    if (args == nil) die("prx -- not enough args");
    prx(car(args));
    return ok_sym;
  >>>>

def (make-queue):
  def front '()
  def rear '()
  def queue ():
    (empty?): is? front '()
    (front):
      if (queue.empty?): error "front called on an empty queue"
      front.car
    (run item):
      def new (cons item '())
      if (queue.empty?):
        do:
          front :: new
          rear :: new
        do:
          rear.set-cdr! new
          rear :: new
      . queue
    (remove!):
      def item queue.front
      queue.delete!
      . item
    (delete!):
      if (queue.empty?): error "delete! called on an empty queue"
      front :: front.cdr
      . queue
    (consume! f):
      if (queue.empty?):
        . 'ok
        do:
          f queue.remove!
          queue.consume! f
  . queue

def (make-promise):
    def status 'pending # or resolved or broken

    def value '()
    def err-name '()
    def err-val '()

    # a queue of functions to run upon success
    # they must be safe to run directly -- they must do the right thing
    def success-queue (make-queue)

    # a queue of functions to run upon success
    # they must be safe to run directly -- they must do the right thing
    def err-queue (make-queue)

    def (resolved?) (is? status 'resolved)
    def (pending?) (is? status 'pending)
    def (broken?) (is? status 'broken)

    def (queue-for-success f):
      if (pending?) (success-queue f)
      if (resolved?) (f value)

    def (queue-for-err f):
      if (pending?) (err-queue f)
      if (broken?) (f err-name err-val)

    def (process state err):
      status :: state
      success-queue :: '()
      err-queue :: '()

    def promise ():
      # This is the fully general wait function.
      #  f is a unary function to filter the value upon fulfillment
      #  h is a binary function to filter the error notice upon breakage
      #
      # There are four possiblities for the resolution of the new promise:
      #
      # 1. The original promise is fulfilled, the filter is successful, and
      #    this promise is fulfilled.
      #
      # 2. The original promise is fulfilled, the filter raises an error, and
      #    this promise is broken.
      #
      # 3. The original promise is broken, the error handler is successful,
      #    and this promise is fulfilled.
      #
      # 4. The original promise is broken, the error handler raises an error,
      #    and this promise is broken.
      (wait+ f h):
        def pp (make-promise)
        def p (pp.car)
        def s (pp.cdr)

        queue-for-success [schedule-task (make-task+ (fn () (f x)) s)]

        queue-for-err [schedule-task (make-task+ (fn () (h x y)) s)]

        . p

      # if there is an error, just re-raise it
      (wait f): promise.wait+ f [error x y]

      # if the promise is fulfilled, just return the value
      (wait-for-error h): promise.wait+ [do x] h

      (send msg args): promise.wait [call x msg args]

    def sink ():
      (run val):
        if (resolved?): error "already resolved"
        status :: 'resolved
        value :: val
        success-queue.consume! [x val]
        process 'resolved
      (break! name val):
        if (broken?): error "already broken"
        status :: 'broken
        err-name :: name
        err-val :: val
        err-queue.consume! [x name val]
        process 'broken

    cons promise sink

def (make-broken-promise name val):
  def pp (make-promise)
  (pp.cdr).break! name val
  . pp

# expects a thunk, returns a (promise, task) pair
def (make-task f):
    def p (make-promise)
    def promise p.car
    def sink p.cdr

    def task (make-task+ f sink)

    cons promise task

# expects a thunk and a sink, returns a task
def (make-task+ f sink): obj ():
  (run): sink (f)
  (break! x): sink.break! 'error x

def (schedule-task task):
  *tasks* task

# expects a thunk, returns a promise
def (make-and-schedule-task f):
  def task-pair (make-task f)
  schedule-task task-pair.cdr
  task-pair.car

def (send rcv msg args):
    if (inspect.has-method? rcv 'send):
        rcv.send msg args
        make-and-schedule-task [call rcv msg args]

def *tasks* (make-queue)
