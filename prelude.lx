# This is the standard prelude for LX.

inline C <<<<
#include "prim.h"
>>>>

def Ï€ 3.14159

def false '()
def true 1

def (not x) (if x false true)

def open (import file)

def call ():
  inline C run <<<<
    datum obj, msg, argl;
    obj = checked_car(args);
    msg = checked_cadr(args);
    argl = checked_caddr(args);
    return call(obj, msg, argl);
  >>>>

def error ():
  inline C run <<<<
    return report_error(args);
  >>>>

def inspect ():
  inline C has-method? <<<<
    return (datum) compiled_obj_has_method(car(args), cadr(args));
  >>>>
  inline C same-type? <<<<
    return (datum) compiled_objs_same_type(car(args), cadr(args));
  >>>>
  inline C methods <<<<
    return (datum) compiled_obj_methods(car(args));
  >>>>

# TODO replace this with 
def (promise? x):
  inspect :has-method? x 'wait

def (ensure try finally):
  def success (fn (x) (finally) x)
  def failure (fn (name val) (finally) (error name val))
  (try .run) :wait+ success failure

def is? ():
  inline C run <<<<
    if (args == nil) die("is? -- not enough args");
    if (cdr(args) == nil) die("is? -- not enough args");
    return (datum) (car(args) == cadr(args));
  >>>>

def cons ():
  inline C run <<<<
    if (args == nil) die("cons -- not enough args");
    if (cdr(args) == nil) die("cons -- not enough args");
    return cons(car(args), cadr(args));
  >>>>

def list ():
  inline C run <<<<
    return args;
  >>>>

def make-array ():
  inline C run <<<<
    if (args == nil) die("make-array -- not enough args");
    if (!intp(car(args))) die1("make-array -- not an int", car(args));
    return make_array(datum2int(car(args)));
  >>>>

def pr ():
  inline C run <<<<
    if (args == nil) die("pr -- not enough args");
    pr(car(args));
    return ok_sym;
  >>>>

def (make-queue):
    def front '()
    def rear '()
    def queue ():
        (empty?):
            is? front '()
        (front):
            if (queue :empty?) (error "front called on an empty queue")
            front :car
        (run item):
            def new (cons item '())
            if (queue :empty?):
                begin :
                    front :: new
                    rear :: new
                begin :
                    rear :set-cdr! new
                    rear :: new
            queue .
        (remove!):
            def item (queue :front)
            queue :delete!
            item .
        (delete!):
            if (queue :empty?) (error "delete! called on an empty queue")
            front :: (front :cdr)
            queue .
        (consume! f):
            if (queue :empty?):
                'ok .
                begin :
                    f (queue :remove!)
                    queue :consume! f
    queue .

def (make-promise):
    def status 'pending # or resolved or broken

    def value '()
    def err-name '()
    def err-val '()

    # a queue of functions to run upon success
    # they must be safe to run directly -- they must do the right thing
    def success-queue (make-queue)

    # a queue of functions to run upon success
    # they must be safe to run directly -- they must do the right thing
    def err-queue (make-queue)

    def (resolved?) (is? status 'resolved)
    def (pending?) (is? status 'pending)
    def (broken?) (is? status 'broken)

    def (queue-for-success f):
      if (pending?) (success-queue f)
      if (resolved?) (f value)

    def (queue-for-err f):
      if (pending?) (err-queue f)
      if (broken?) (f err-name err-val)

    def (process state err):
      status :: state
      success-queue :: '()
      err-queue :: '()

    def promise ():
        # This is the fully general wait function.
        #  f is a unary function to filter the value upon fulfillment
        #  h is a binary function to filter the error notice upon breakage
        #
        # There are four possiblities for the resolution of the new promise:
        #
        # 1. The original promise is fulfilled, the filter is successful, and
        #    this promise is fulfilled.
        #
        # 2. The original promise is fulfilled, the filter raises an error, and
        #    this promise is broken.
        #
        # 3. The original promise is broken, the error handler is successful,
        #    and this promise is fulfilled.
        #
        # 4. The original promise is broken, the error handler raises an error,
        #    and this promise is broken.
        (wait+ f h):
          def pp (make-promise)
          def p (pp :car)
          def s (pp :cdr)

          def success :
            fn (x) (schedule-task (make-task+ (fn () (f x)) s))
          queue-for-success success

          def failure :
            fn (x y) (schedule-task (make-task+ (fn () (h x y)) s))
          queue-for-err failure

          p .

        (wait f):
          # if there is an error, just re-raise it
          promise :wait+ f (fn (name val) (error name val))

        (wait-for-error h):
          # if the promise is fulfilled, just return the value
          promise :wait+ (fn (x) x) h

        (send msg args):
            if (pending?):
                promise :wait (fn (x) (def v (call x msg args)) v)
                if (resolved?):
                    send value msg args
                    make-broken-promise err-name err-val # status is 'broken

    def sink ():
        (run val):
            if (resolved?) (error "already resolved")
            status :: 'resolved
            value :: val
            #success-queue :consume! [x val]
            success-queue :consume! (fn (x) (x val))
            process 'resolved
        (break! name val):
            if (broken?) (error "already broken")
            status :: 'broken
            err-name :: name
            err-val :: val
            #err-queue :consume! [x name val]
            err-queue :consume! (fn (x) (x name val))
            process 'broken

    cons promise sink

def (make-broken-promise name val):
  def pp (make-promise)
  (pp :cdr) :break! name val
  pp .

# expects a thunk, returns a (promise, task) pair
def (make-task f):
    def p (make-promise)
    def promise (p :car)
    def sink (p :cdr)

    def task (make-task+ f sink)

    cons promise task

# expects a thunk and a sink, returns a task
def (make-task+ f sink):
  obj ():
    (run) (def x (f)) (sink x)
    (break! x) (sink :break! 'error x)

def (schedule-task task):
  *tasks* task

# expects a thunk, returns a promise
def (make-and-schedule-task f):
  def task-pair (make-task f)
  schedule-task (task-pair :cdr)
  task-pair :car

def (send rcv msg args):
    if (inspect :has-method? rcv 'send):
        rcv :send msg args
        make-and-schedule-task (fn () (def x (call rcv msg args)) x)

def *tasks* (make-queue)
