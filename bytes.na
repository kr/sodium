
inline C <<end

#include <string.h>

#include "bytes.h"
#include "prim.h"

static datum percent_star_sym;

void
bytes_init()
{
    percent_star_sym = intern("%*");
}

datum
make_bytes(uint size)
{
    return make_opaque(size, mtab);
}

datum
make_bytes_init_len(const char *s, int len)
{
    datum d = make_bytes(len);
    memcpy(bytes_contents(d), s, len);
    return d;
}

datum
make_bytes_init(const char *s)
{
    return make_bytes_init_len(s, strlen(s));
}

size_t
copy_bytes_contents(char *dest, datum bytes, size_t n)
{
    char *x = bytes_contents(bytes);
    if (datum_size(bytes) < n) n = datum_size(bytes);
    memcpy(dest, x, n);
    return n;
}

size_t
copy_bytes_contents0(char *dest, datum bytes, size_t n)
{
    n = copy_bytes_contents(dest, bytes, n - 1);
    dest[n] = 0;
    return n + 1;
}

char *
bytes_contents(datum bytes)
{
    if (!bytesp(bytes)) die1("bytes_contents -- not an instance of bytes", bytes);
    return (char *) bytes;
}

int
bytesp(datum x)
{
    return (!(((size_t) x) & 1)) && (((datum) x[-1]) == mtab);
}

end

def bytes: sobj:
  inline C (/ x) <<end
    /* concatenate */
    char *new_str;
    size_t l1 = datum_size(rcv), l2 = datum_size(n_x);
    char s1[l1], s2[l2];

    copy_bytes_contents(s1, rcv, l1);
    copy_bytes_contents(s2, n_x, l2);
    new_str = (char *) make_bytes(l1 + l2);
    memcpy(new_str, s1, l1);
    memcpy(new_str + l1, s2, l2);

    return (datum) new_str;
  end

  inline C (decode.) <<end
    /* TODO check for valid UTF-8 */
    return make_str_init(datum_size(rcv), (char *) rcv);
  end

  inline C (run i) <<end
    /* index a single byte */
    int i;

    if (!intp(n_i)) die("bytes -- expected int");
    i = datum2int(n_i);

    if (i > datum_size(rcv)) return nil;
    return int2datum(bytes_contents(rcv)[i]);
  end

  inline C (length.) <<end
    return int2datum(datum_size(rcv));
  end

  inline C (== x) <<end
    size_t i, rcv_size = datum_size(rcv), n_x_size = datum_size(n_x);

    if (rcv_size != n_x_size) return nil;
    for (i = 0; i < rcv_size; i++) {
        if (((char *) rcv)[i] != ((char *) n_x)[i]) return nil;
    }
    return int2datum(1);
  end

  inline C (substring start end) <<end
    int start, end;
    size_t len = datum_size(rcv);
    char s[len];
    datum new;

    copy_bytes_contents(s, rcv, len);

    start = datum2int(n_start);
    end = datum2int(n_end);

    /* allow negative indices to count from the end */
    if (start < 0) start = len - start;
    if (end < 0) end = len - end;

    /* out-of-bounds indices refer to the beginning or end of the string */
    if (start < 0) start = 0;
    if (end < 0) end = 0;
    if (start > len) start = len;
    if (end > len) end = len;

    new = make_bytes(end - start);
    memcpy(new, s + start, end - start);
    return new;
  end

  (tail n) (self.substring n (self.length))
  (head n):
    self.substring 0 n

  (starts-with? sub):
    (self.head (sub.length)) == sub

  (find-from n sub):
    def (helper s i):
      ? ((s.length) < (sub.length)):
        i + (s.length)
        ? (s.starts-with? sub):
          . i
          helper (s.tail 1) (i + 1)
    helper (self.tail n) n

  (find sub):
    self.find-from 0 sub

  # (% . a):
  #   pr "in %"
  #   def i (self.find "%")
  #   ? (not i):
  #     . self
  #     ? ((self 0) == "%"):
  #       (format (self 1) (a.car)) / ((self.tail 2) % . (a.cdr))
  #       (self.head i) / ((self.tail i) % . a)

  (%* a):
    def (format code val):
      to-str val
    def l (self.length)
    def i (self.find "%")
    ? (is? i l):
      . self
      ? ((self 0) == "%"):
        (format (self 1) (a.car)) / ((self.tail 2).%* (a.cdr))
        (self.head i) / ((self.tail i).%* a)

  inline C "%" <<end
    regs[R_VM0] = rcv;
    args = cons(args, nil);
    return call(regs[R_VM0], percent_star_sym, args);
  end

def (to-str x):
  ? (inspect.same-type? x str):
    . x
    to-str (x.str)

. '()
