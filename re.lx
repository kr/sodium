inline C <<<<

#include <string.h>
#include <pcre.h>

#define OVECCOUNT 30

int ovector[OVECCOUNT];

>>>>

def re ():
  inline C dotall <<<<
    return int2datum(PCRE_DOTALL);
  >>>>

  (run pat) (re.make pat (re.dotall))

  (make pat opts):
    def r ():
      (run subj) (r.match subj (r.runopts))
      (find subj) (r.match subj (r.findopts))

      inline C runopts <<<<
        return int2datum(PCRE_ANCHORED);
      >>>>

      inline C findopts <<<<
        return int2datum(0);
      >>>>

      inline C match <<<<
        char *subj, *res;
        int rc, subj_len, res_len, opts;
        pcre *re = (pcre *) ((pair) rcv)->datums[2];

        if (args == nil) die("r.match -- not enough args");
        subj = bytes_contents(car(args));
        subj_len = strlen(subj);
        args = cdr(args);

        if (args == nil) die("r.match -- not enough args");
        opts = datum2int(car(args));
        args = cdr(args);

        if (args != nil) die("r.match -- too many args");

        rc = pcre_exec(re, NULL, subj, subj_len, 0, opts, ovector, OVECCOUNT);

        if (rc < 0) return nil;
        if (rc == 0) return nil;

        res = subj + ovector[0];
        res_len = ovector[1] - ovector[0];
        return make_bytes_init_len(res, res_len);
      >>>>

      inline C finalize! <<<<
        free(((pair) rcv)->datums[2]);
        return ok_sym;
      >>>>

      inline C prepare <<<<
        pcre *re;
        const char *error;
        char *pattern;
        int erroffset, opts;
        datum d;

        if (args != nil) die("r.prepare -- too many args");

        d = make_obj_with_extra(rcv, 1);

        pattern = bytes_contents(%(pat)s);
        opts = datum2int(%(opts)s);
        re = pcre_compile(pattern, opts, &error, &erroffset, NULL);
        if (re == NULL) return nil;

        ((pair) d)->datums[2] = (datum) re;
        return d;
      >>>>

    r :: (r.prepare)
    . r

. re
