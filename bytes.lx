
inline C <<end

#include <string.h>

#include "prim.h"

static datum percent_star_sym;

typedef struct bytes {
    uint info;
    size_t size;
    char data[];
} *bytes;

static inline bytes
datum2bytes(datum d)
{
    if (!bytesp(d)) die1("not a bytes", d);
    return (bytes) d;
}

end

def bytes ():
  inline C (/ x) <<end
    /* concatenate */
    datum new_str;
    int l1, l2;
    char *s1, *s2, *s;

    s1 = copy_bytes_contents(rcv);
    s2 = copy_bytes_contents(n_x);
    l1 = strlen(s1);
    l2 = strlen(s2);
    new_str = make_bytes(l1 + l2 + 1);
    s = bytes_contents(new_str);
    strcpy(s, s1);
    strcpy(s + l1, s2);
    s[l1 + l2] = '\0';
    free(s1);
    free(s2);

    return new_str;
  end

  inline C (decode) <<end
    bytes b = datum2bytes(rcv);

    /* TODO check for valid UTF-8 and count runes */
    /* assume only ASCII for now */
    return make_str_init(b->size, b->size, b->data);
  end

  inline C (run i) <<end
    /* index a single char */
    int i;
    char s[2];

    if (!intp(n_i)) die("bytes -- expected int");
    i = datum2int(n_i);
    s[0] = bytes_contents(rcv)[i];
    s[1] = '\0';
    return make_bytes_init(s);
  end

  inline C (length) <<end
    return int2datum(strlen(bytes_contents(rcv)));
  end

  inline C (= x) <<end
    char *s1, *s2;
    int i, l1, l2;

    if (!bytesp(n_x)) return nil;
    s1 = bytes_contents(rcv);
    s2 = bytes_contents(n_x);

    l1 = strlen(s1);
    l2 = strlen(s2);
    if (l1 != l2) return nil;

    for (i = 0; i < l1; i++) {
        if (s1[i] != s2[i]) return nil;
    }
    return int2datum(1);
  end

  inline C (substring start end) <<end
    char *s;
    int start, end, len;

    s = bytes_contents(rcv);
    len = strlen(s);

    start = datum2int(n_start);
    if (start < 0) start = 0;

    end = datum2int(n_end);
    if (end > len) end = len;

    {
        int i, j;
        char new[end - start + 1];
        for (i = 0, j = start; j < end; i++, j++) {
            new[i] = s[j];
        }
        new[i] = '\0';
        return make_bytes_init(new);
    }
  end

  (tail n) (bytes.substring n (bytes.length))
  (head n):
    bytes.substring 0 n

  (starts-with? sub):
    (bytes.head (sub.length)) = sub

  (find-from n sub):
    def (helper s i):
      ? ((s.length) < (sub.length)):
        i + (s.length)
        ? (s.starts-with? sub):
          . i
          helper (s.tail 1) (i + 1)
    helper (bytes.tail n) n

  (find sub):
    bytes.find-from 0 sub

  # (% . a):
  #   pr "in %"
  #   def i (bytes.find "%")
  #   ? (not i):
  #     . bytes
  #     ? ((bytes 0) = "%"):
  #       (format (bytes 1) (a.car)) / ((bytes.tail 2) % . (a.cdr))
  #       (bytes.head i) / ((bytes.tail i) % . a)

  (%* a):
    def (format code val):
      to-str val
    def l (bytes.length)
    def i (bytes.find "%")
    ? (is? i l):
      . bytes
      ? ((bytes 0) = "%"):
        (format (bytes 1) (a.car)) / ((bytes.tail 2).%* (a.cdr))
        (bytes.head i) / ((bytes.tail i).%* a)

  inline C % <<end
    regs[R_VM0] = rcv;
    args = cons(args, nil);
    return call(regs[R_VM0], percent_star_sym, args);
  end

def intern-syms ():
  inline C run <<end
    percent_star_sym = intern("%%*");
    return ok_sym;
  end

def install-bytes ():
  inline C (run sur) <<end
    bytes_surrogate = n_sur;
    return ok_sym;
  end

def (to-str x):
  ? (inspect.same-type? x str):
    . x
    to-str (x.str)

intern-syms
install-bytes bytes

. '()
