
inline C <<end

#include <string.h>

#include "prim.h"

static datum percent_star_sym;

typedef struct bytes {
    uint info;
    size_t size;
    char data[];
} *bytes;

static inline bytes
datum2bytes(datum d)
{
    if (!bytesp(d)) die1("not a bytes", d);
    return (bytes) d;
}

end

def bytes ():
  inline C (/ x) <<end
    /* concatenate */
    bytes new_str;
    size_t l1 = bytes_len(rcv), l2 = bytes_len(n_x);
    char s1[l1], s2[l2];

    copy_bytes_contents(s1, rcv, l1);
    copy_bytes_contents(s2, n_x, l2);
    new_str = (bytes) make_bytes(l1 + l2);
    memcpy(new_str->data, s1, l1);
    memcpy(new_str->data + l1, s2, l2);

    return (datum) new_str;
  end

  inline C (decode) <<end
    bytes b = datum2bytes(rcv);

    /* TODO check for valid UTF-8 and count runes */
    /* assume only ASCII for now */
    return make_str_init(b->size, b->size, b->data);
  end

  inline C (run i) <<end
    /* index a single byte */
    int i;

    if (!intp(n_i)) die("bytes -- expected int");
    i = datum2int(n_i);

    if (i > bytes_len(rcv)) return nil;
    return int2datum(bytes_contents(rcv)[i]);
  end

  inline C (length) <<end
    return int2datum(bytes_len(rcv));
  end

  inline C (= x) <<end
    size_t i;
    bytes a = datum2bytes(rcv), b = datum2bytes(n_x);

    if (a->size != b->size) return nil;
    for (i = 0; i < a->size; i++) {
        if (a->data[i] != b->data[i]) return nil;
    }
    return int2datum(1);
  end

  inline C (substring start end) <<end
    int start, end;
    size_t len = bytes_len(rcv);
    char s[len];
    bytes new;

    copy_bytes_contents(s, rcv, len);

    start = datum2int(n_start);
    end = datum2int(n_end);

    /* allow negative indices to count from the end */
    if (start < 0) start = len - start;
    if (end < 0) end = len - end;

    /* out-of-bounds indices refer to the beginning or end of the string */
    if (start < 0) start = 0;
    if (end < 0) end = 0;
    if (start > len) start = len;
    if (end > len) end = len;

    new = (bytes) make_bytes(end - start);
    memcpy(new->data, s + start, end - start);
    return (datum) new;
  end

  (tail n) (bytes.substring n (bytes.length))
  (head n):
    bytes.substring 0 n

  (starts-with? sub):
    (bytes.head (sub.length)) = sub

  (find-from n sub):
    def (helper s i):
      ? ((s.length) < (sub.length)):
        i + (s.length)
        ? (s.starts-with? sub):
          . i
          helper (s.tail 1) (i + 1)
    helper (bytes.tail n) n

  (find sub):
    bytes.find-from 0 sub

  # (% . a):
  #   pr "in %"
  #   def i (bytes.find "%")
  #   ? (not i):
  #     . bytes
  #     ? ((bytes 0) = "%"):
  #       (format (bytes 1) (a.car)) / ((bytes.tail 2) % . (a.cdr))
  #       (bytes.head i) / ((bytes.tail i) % . a)

  (%* a):
    def (format code val):
      to-str val
    def l (bytes.length)
    def i (bytes.find "%")
    ? (is? i l):
      . bytes
      ? ((bytes 0) = "%"):
        (format (bytes 1) (a.car)) / ((bytes.tail 2).%* (a.cdr))
        (bytes.head i) / ((bytes.tail i).%* a)

  inline C % <<end
    regs[R_VM0] = rcv;
    args = cons(args, nil);
    return call(regs[R_VM0], percent_star_sym, args);
  end

def intern-syms ():
  inline C run <<end
    percent_star_sym = intern("%*");
    return ok_sym;
  end

def install-bytes ():
  inline C (run sur) <<end
    bytes_surrogate = n_sur;
    return ok_sym;
  end

def (to-str x):
  ? (inspect.same-type? x str):
    . x
    to-str (x.str)

intern-syms
install-bytes bytes

. '()
