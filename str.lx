
inline C <<<<

#include <string.h>

#include "prim.h"

static datum percent_star_sym;

>>>>

def str ():
  inline C / <<<<
    /* concatenate */
    datum new_str;
    int l1, l2;
    char *s1, *s2, *s;

    if (args == nil) die("str./ -- not enough args");
    if (cdr(args) != nil) die("str./ -- too many args");

    s1 = copy_string_contents(rcv);
    s2 = copy_string_contents(car(args));
    l1 = strlen(s1);
    l2 = strlen(s2);
    new_str = make_string(l1 + l2 + 1);
    s = string_contents(new_str);
    strcpy(s, s1);
    strcpy(s + l1, s2);
    s[l1 + l2] = '\0';
    free(s1);
    free(s2);

    return new_str;
  >>>>

  inline C run <<<<
    /* index a single char */
    int i;
    char s[2];

    if (args == nil) die("str -- not enough args");
    if (!intp(car(args))) die("str -- expected int");
    i = datum2int(car(args));
    s[0] = string_contents(rcv)[i];
    s[1] = '\0';
    return make_string_init(s);
  >>>>

  inline C length <<<<
    if (args != nil) die("str.length -- too many args");
    return int2datum(strlen(string_contents(rcv)));
  >>>>

  inline C = <<<<
    char *s1, *s2;
    int i, l1, l2;

    if (args == nil) die("str.= -- not enough args");
    if (cdr(args) != nil) die("str.= -- too many args");

    if (!stringp(car(args))) return nil;
    s1 = string_contents(rcv);
    s2 = string_contents(car(args));

    l1 = strlen(s1);
    l2 = strlen(s2);
    if (l1 != l2) return nil;

    for (i = 0; i < l1; i++) {
        if (s1[i] != s2[i]) return nil;
    }
    return int2datum(1);
  >>>>

  inline C substring <<<<
    char *s;
    int start, end, len;

    if (args == nil) die("str.substring -- not enough args");
    if (cdr(args) == nil) die("str.substring -- not enough args");
    if (cddr(args) != nil) die("str.substring -- too many args");

    s = string_contents(rcv);
    len = strlen(s);

    start = datum2int(car(args));
    if (start < 0) start = 0;

    end = datum2int(cadr(args));
    if (end > len) end = len;

    {
        int i, j;
        char new[end - start + 1];
        for (i = 0, j = start; j < end; i++, j++) {
            new[i] = s[j];
        }
        new[i] = '\0';
        return make_string_init(new);
    }
  >>>>

  (tail n) (str.substring n (str.length))
  (head n):
    str.substring 0 n

  (starts-with? sub):
    (str.head (sub.length)) = sub

  (find-from n sub):
    def (helper s i):
      if ((s.length) < (sub.length)):
        i + (s.length)
        if (s.starts-with? sub):
          . i
          helper (s.tail 1) (i + 1)
    helper (str.tail n) n

  (find sub):
    str.find-from 0 sub

  # (% . a):
  #   pr "in %"
  #   def i (str.find "%")
  #   if (not i):
  #     . str
  #     if ((str 0) = "%"):
  #       (format (str 1) (a.car)) / ((str.tail 2) % . (a.cdr))
  #       (str.head i) / ((str.tail i) % . a)

  (%* a):
    def (format code val):
      to-str val
    def l (str.length)
    def i (str.find "%")
    if (is? i l):
      . str
      if ((str 0) = "%"):
        (format (str 1) (a.car)) / ((str.tail 2).%* (a.cdr))
        (str.head i) / ((str.tail i).%* a)

  inline C % <<<<
    regs[R_VM0] = rcv;
    args = cons(args, nil);
    return call(regs[R_VM0], percent_star_sym, args);
  >>>>

def intern-syms ():
  inline C run <<<<
    percent_star_sym = intern("%%*");
    return ok_sym;
  >>>>

def install-str ():
  inline C run <<<<
    if (args == nil) die("install-str -- not enough args");
    str_surrogate = car(args);
    return ok_sym;
  >>>>

def (to-str x):
  if (inspect.same-type? x str):
    . x
    to-str (x.str)

intern-syms
install-str str

. '()
