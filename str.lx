
inline C <<<<

#include <string.h>

#include "prim.h"

static datum percent_star_sym;

>>>>

def str ():
  inline C / <<<<
    /* concatenate */
    datum new_str;
    int l1, l2;
    char *s1, *s2, *s;

    if (args == nil) die("str:/ -- not enough args");
    if (cdr(args) != nil) die("str:/ -- too many args");

    s1 = copy_string_contents(rcv);
    s2 = copy_string_contents(car(args));
    l1 = strlen(s1);
    l2 = strlen(s2);
    new_str = make_string(l1 + l2 + 1);
    s = string_contents(new_str);
    strcpy(s, s1);
    strcpy(s + l1, s2);
    s[l1 + l2] = '\0';
    free(s1);
    free(s2);

    return new_str;
  >>>>

  inline C run <<<<
    /* index a single char */
    int i;
    char s[2];

    if (args == nil) die("str -- not enough args");
    if (!intp(car(args))) die("str -- expected int");
    i = datum2int(car(args));
    s[0] = string_contents(rcv)[i];
    s[1] = '\0';
    return make_string_init(s);
  >>>>

  inline C length <<<<
    if (args != nil) die("str:length -- too many args");
    return int2datum(strlen(string_contents(rcv)));
  >>>>

  inline C = <<<<
    char *s1, *s2;
    int i, l1, l2;

    if (args == nil) die("str:= -- not enough args");
    if (cdr(args) != nil) die("str:= -- too many args");

    if (!stringp(car(args))) return nil;
    s1 = string_contents(rcv);
    s2 = string_contents(car(args));

    l1 = strlen(s1);
    l2 = strlen(s2);
    if (l1 != l2) return nil;

    for (i = 0; i < l1; i++) {
        if (s1[i] != s2[i]) return nil;
    }
    return int2datum(1);
  >>>>

  inline C substring <<<<
    char *s;
    int start, end, len;

    if (args == nil) die("str:substring -- not enough args");
    if (cdr(args) == nil) die("str:substring -- not enough args");
    if (cddr(args) != nil) die("str:substring -- too many args");

    s = string_contents(rcv);
    len = strlen(s);

    start = datum2int(car(args));
    if (start < 0) start = 0;

    end = datum2int(cadr(args));
    if (end > len) end = len;

    {
        int i, j;
        char new[end - start + 1];
        for (i = 0, j = start; j < end; i++, j++) {
            new[i] = s[j];
        }
        new[i] = '\0';
        return make_string_init(new);
    }
  >>>>

  (tail n) (str :substring n (str :length))
  (head n) (str :substring 0 n)

  (starts-with sub):
    (str :head (sub :length)) = sub

  (find-from n sub):
    def (helper s i):
      if (s :starts-with sub):
        i .
        helper (s :tail 1) (i + 1)
    helper (str :tail n) n

  (find sub):
    str :find-from 0 sub

  # (% . a):
  #   pr "in %"
  #   def i (str :find "%")
  #   if (not i):
  #     str .
  #     if ((str 0) = "%"):
  #       (format (str 1) (a :car)) / ((str :tail 2) % . (a :cdr))
  #       (str :head i) / ((str :tail i) % . a)

  inline C % <<<<
    uint n, i;
    datum str;
    char *f, *s, *dest, *a, *fmt = copy_string_contents(rcv);


    regs[R_VM0] = regs[R_VM1] = args;

    /* first, find a upper bound on the string size */
    n = 1; /* one for the null terminator */
    for (f = fmt; *f; f++) {
        if (*f != '%%') { n++; continue; }
        switch (*++f) {
            case 'c':
                regs[R_VM1] = cdr(regs[R_VM1]);
                /* fall through */
            case '%%':
                n++;
                break;
            case 'd':
                regs[R_VM1] = cdr(regs[R_VM1]);
                n += 20;
                break;
            case 'r': /* repr */
                car(regs[R_VM1]) = make_string_init("$$$");
                /* fall through */
            case 'p': /* pretty */
                car(regs[R_VM1]) = make_string_init("###");
                /* fall through */
            case 's':
                n += strlen(string_contents(car(regs[R_VM1])));
                regs[R_VM1] = cdr(regs[R_VM1]);
                break;
            default:
                free(fmt);
                die("prim_str -- unknown formatting code");
        }
    }

    s = dest = malloc(sizeof(char) * n);
    if (!dest) {
        free(fmt);
        die("prim_str -- out of memory");
    }

    /* second, format the string */
    for (f = fmt; *f; f++) {
        if (*f != '%%') {
            *s++ = *f;
            continue;
        }
        switch (*++f) {
            case 'c':
                free(s);
                free(fmt);
                die("prim_str -- OOPS I have not implemented chars yet");
                regs[R_VM0] = cdr(regs[R_VM0]);
                break;
            case '%%':
                *s++ = '%%';
                break;
            case 'd':
                sprintf(s, "%%d", datum2int(car(regs[R_VM0])));
                s += strlen(s);
                regs[R_VM0] = cdr(regs[R_VM0]);
                break;
            case 'r': /* repr */
                car(regs[R_VM0]) = make_string_init("$$$");
                /* fall through */
            case 'p': /* pretty */
                car(regs[R_VM0]) = make_string_init("###");
                /* fall through */
            case 's':
                a = string_contents(car(regs[R_VM0]));
                i = strlen(a);
                memcpy(s, a, i);
                regs[R_VM0] = cdr(regs[R_VM0]);
                s += i;
                break;
            default:
                free(s);
                free(fmt);
                die("prim_str -- unknown formatting code");
        }
    }
    *s = '\0';

    str = make_string_init(dest);
    free(dest);
    free(fmt);
    return str;
  >>>>

def intern-syms ():
  inline C run <<<<
    percent_star_sym = intern("%%*");
    return ok_sym;
  >>>>

def install-str ():
  inline C run <<<<
    if (args == nil) die("install-str -- not enough args");
    str_surrogate = car(args);
    return ok_sym;
  >>>>


intern-syms
install-str str

'() .
