inline C <<end
#include <string.h>
#include "symbol.h"

#include <stdlib.h>
#include <string.h>
#include "symbol.h"
#include "gen.h"
#include "obj.h"
#include "prim.h"

#define CHAR_STAR_TAG 0x2
#define symbol2datum(x) ((datum) (((unsigned int)(x)) | CHAR_STAR_TAG))
#define datum2symbol(x) ((symbol) (((unsigned int)(x)) & ~CHAR_STAR_TAG))

typedef struct symbol *symbol;

struct symbol {
    symbol next;
    char chars[];
};

static size_t cap = 0, fill = 0;
static symbol *symbols = 0;

static datum symbol_mtab;

void
symbol_init()
{
    symbol_mtab = (datum) lxc_module_symbol.instrs +
                          lxc_module_symbol.label_offsets[4];
}

/* Yikes, this is expensive. There has got to be a better way. */
static uint
next_prime(uint n)
{
    uint i;

    if (n < 2) return 2;
    if (n % 2 == 0) ++n;
    for (;; n += 2) {
        for (i = 3; i * i <= n && n % i != 0; i += 2) {}
        if (i * i > n) return n;
    }
}

static datum store(symbol ent);

static void
rehash()
{
    symbol *old = symbols;
    size_t old_cap = cap, i;

    cap = next_prime(cap << 1);
    symbols = malloc(sizeof(datum) * cap);
    if (!symbols) die("OOM allocating symbol table");
    fill = 0;

    for (i = 0; i < old_cap; i++) {
        while (old[i]) {
            symbol ent = old[i];
            old[i] = ent->next;
            ent->next = 0;
            store(ent);
        }
    }
    free(old);
}

static uint
hash(const char *s)
{
    return 0;
}

static datum
store(symbol ent)
{
    int i;

    if (fill >= (cap << 2)) rehash();

    i = hash(ent->chars) % cap;

    ent->next = symbols[i];
    symbols[i] = ent;
    fill++;

    return symbol2datum(ent);
}

static symbol
make_st_ent(const char *s)
{
    symbol ent;

    ent = malloc(sizeof(struct symbol) + sizeof(char) * (strlen(s) + 1));
    strcpy(ent->chars, s);

    return ent;
}

static datum
lookup_sym(const char *s)
{
    int i;
    symbol sh;

    if (!cap) return nil;

    i = hash(s) % cap;

    for (sh = symbols[i]; sh; sh = sh->next) {
        if (strcmp(s, sh->chars) == 0) {
            return symbol2datum(sh);
        }
    }
    return nil;
}

datum
intern(const char *s)
{
    datum sym;

    sym = lookup_sym(s);
    if (sym != nil) return sym;

    return store(make_st_ent(s));
}

void
dump_symbol(void *s)
{
    symbol sym;
    if (!symbolp(s)) {
        prfmt(1, "<bad-symbol>");
        return;
    }
    sym = datum2symbol(s);
    prfmt(1, "symbol\n  %s", sym->chars);
}

void
pr_symbol(void *s)
{
    symbol sym;
    if (!symbolp(s)) {
        prfmt(1, "<bad-symbol>");
        return;
    }
    sym = datum2symbol(s);
    prfmt(1, "%s", sym->chars);
}

int
symbolp(datum d)
{
    return ((((uint) d) & 0x3) == CHAR_STAR_TAG);
}

const char *
symbol2charstar(datum s)
{
    symbol sym;

    if (!symbolp(s)) die1("symbol2charstar -- not a symbol", s);

    sym = datum2symbol(s);
    return sym->chars;
}

end

def symbol ():
  inline C str <<end
    const char *cont;
    size_t len;

    cont = symbol2charstar(rcv);
    len = strlen(cont);
    return make_str_init(len, cont);
  end

def install-symbol ():
  inline C (run sur) <<end
    symbol_surrogate = n_sur;
    return ok_sym;
  end

install-symbol symbol

. '()
