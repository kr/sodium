inline C <<end
#include <string.h>
#include "symbol.h"

#include <stdlib.h>
#include <string.h>
#include "symbol.h"
#include "gen.h"
#include "obj.h"
#include "prim.h"

typedef struct symbol *symbol;

struct symbol {
    datum next;
    datum str;
};

static size_t cap = 0, fill = 0;
static datum *symbols = 0;

static datum symbol_mtab;

void
symbol_init()
{
    symbol_mtab = (datum) lxc_module_symbol.instrs +
                          lxc_module_symbol.label_offsets[4];
}

/* Yikes, this is expensive. There has got to be a better way. */
static uint
next_prime(uint n)
{
    uint i;

    if (n < 2) return 2;
    if (n % 2 == 0) ++n;
    for (;; n += 2) {
        for (i = 3; i * i <= n && n % i != 0; i += 2) {}
        if (i * i > n) return n;
    }
}

static datum store(symbol ent);

static void
rehash()
{
    datum *old = symbols;
    size_t old_cap = cap, i;

    cap = next_prime(cap << 1);
    symbols = malloc(sizeof(datum) * cap);
    if (!symbols) die("OOM allocating symbol table");
    fill = 0;
    for (i = 0; i < cap; i++) symbols[i] = nil;

    for (i = 0; i < old_cap; i++) {
        while (old[i] != nil) {
            symbol ent = (symbol) old[i];
            old[i] = ent->next;
            ent->next = nil;
            store(ent);
        }
    }
    free(old);
}

static uint
hash(size_t n, const char *s)
{
    return 0;
}

static datum
store(symbol ent)
{
    int i;

    if (fill >= (cap << 2)) rehash();

    i = hash(datum_size(ent->str), (char *) ent->str) % cap;

    fill++;
    ent->next = symbols[i];
    return symbols[i] = (datum) ent;
}

static datum
make_st_ent(const char *s)
{
    datum str;

    str = make_str_init_permanent(strlen(s), s);
    return make_record_permanent(2, symbol_mtab, nil, str);
}

static datum
lookup_sym(const char *s)
{
    int i;
    datum sh;

    if (!cap) return nil;

    i = hash(strlen(s), s) % cap;

    for (sh = symbols[i]; sh != nil; sh = ((symbol) sh)->next) {
        if (str_cmp_charstar(((symbol) sh)->str, s) == 0) {
            return sh;
        }
    }
    return nil;
}

datum
intern(const char *s)
{
    datum sym;

    sym = lookup_sym(s);
    if (sym != nil) return sym;

    return store((symbol) make_st_ent(s));
}

void
pr_symbol(datum sym)
{
    if (!symbolp(sym)) return prfmt(1, "<bad-symbol>");
    prx(((symbol) sym)->str);
}

int
symbolp(datum x)
{
    return (!(((size_t)x)&1) && ((datum) x[-1]) == symbol_mtab);
}

size_t
symbol_copy0(char *dest, size_t n, datum sym)
{
    if (!symbolp(sym)) die1("not a symbol", sym);
    return copy_str_contents0(dest, ((symbol) sym)->str, n);
}

end

def symbol ():
  inline C str <<end
    return ((symbol) rcv)->str;
  end

def install-symbol ():
  inline C (run sur) <<end
    symbol_surrogate = n_sur;
    return ok_sym;
  end

install-symbol symbol

. '()
