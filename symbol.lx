inline C <<end
#include <string.h>
#include "symbol.h"

#include <stdlib.h>
#include <string.h>
#include "symbol.h"
#include "gen.h"
#include "obj.h"
#include "prim.h"

#define CHAR_STAR_TAG 0x2

typedef struct symbol *symbol;

struct symbol {
    datum next;
    datum str;
};

static size_t cap = 0, fill = 0;
static datum *symbols = 0;

static datum symbol_mtab;

static inline datum
symbol2datum(symbol s)
{
    if (!s) return nil;
    return (datum) (CHAR_STAR_TAG | (size_t) s);
}

static inline symbol
datum2symbol(datum d)
{
    if (d == nil) return 0;
    return (symbol) ((size_t) d & ~CHAR_STAR_TAG);
}

void
symbol_init()
{
    symbol_mtab = (datum) lxc_module_symbol.instrs +
                          lxc_module_symbol.label_offsets[4];
}

/* Yikes, this is expensive. There has got to be a better way. */
static uint
next_prime(uint n)
{
    uint i;

    if (n < 2) return 2;
    if (n % 2 == 0) ++n;
    for (;; n += 2) {
        for (i = 3; i * i <= n && n % i != 0; i += 2) {}
        if (i * i > n) return n;
    }
}

static datum store(symbol ent);

static void
rehash()
{
    datum *old = symbols;
    size_t old_cap = cap, i;

    cap = next_prime(cap << 1);
    symbols = malloc(sizeof(datum) * cap);
    if (!symbols) die("OOM allocating symbol table");
    fill = 0;
    for (i = 0; i < cap; i++) symbols[i] = nil;

    for (i = 0; i < old_cap; i++) {
        while (old[i] != nil) {
            symbol ent = datum2symbol(old[i]);
            old[i] = ent->next;
            ent->next = nil;
            store(ent);
        }
    }
    free(old);
}

static uint
hash(size_t n, const char *s)
{
    return 0;
}

static datum
store(symbol ent)
{
    int i;

    if (fill >= (cap << 2)) rehash();

    i = hash(datum_size(ent->str), (char *) ent->str) % cap;

    ent->next = symbols[i];
    symbols[i] = symbol2datum(ent);
    fill++;

    return symbol2datum(ent);
}

static symbol
make_st_ent(const char *s)
{
    symbol ent;

    ent = malloc(sizeof(struct symbol));
    ent->str = make_str_init_permanent(strlen(s), s);

    return ent;
}

static datum
lookup_sym(const char *s)
{
    int i;
    symbol sh;

    if (!cap) return nil;

    i = hash(strlen(s), s) % cap;

    for (sh = datum2symbol(symbols[i]); sh; sh = datum2symbol(sh->next)) {
        if (str_cmp_charstar(sh->str, s) == 0) {
            return symbol2datum(sh);
        }
    }
    return nil;
}

datum
intern(const char *s)
{
    datum sym;

    sym = lookup_sym(s);
    if (sym != nil) return sym;

    return store(make_st_ent(s));
}

void
dump_symbol(void *s)
{
    symbol sym;
    if (!symbolp(s)) {
        prfmt(1, "<bad-symbol>");
        return;
    }
    sym = datum2symbol(s);
    prfmt(1, "symbol\n  ");
    pr(sym->str);
}

void
pr_symbol(void *s)
{
    symbol sym;
    if (!symbolp(s)) {
        prfmt(1, "<bad-symbol>");
        return;
    }
    sym = datum2symbol(s);
    prx(sym->str);
}

int
symbolp(datum d)
{
    return ((((uint) d) & 0x3) == CHAR_STAR_TAG);
}

size_t
symbol_copy0(char *dest, size_t n, datum sym)
{
    symbol s = datum2symbol(sym);
    return copy_str_contents0(dest, s->str, n);
}

end

def symbol ():
  inline C str <<end
    symbol s = datum2symbol(rcv);
    return s->str;
  end

def install-symbol ():
  inline C (run sur) <<end
    symbol_surrogate = n_sur;
    return ok_sym;
  end

install-symbol symbol

. '()
